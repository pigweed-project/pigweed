# Copyright 2025 The Pigweed Authors
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

"""Aspect for running Pylint on py_* targets."""

load("@rules_python//python:py_info.bzl", "PyInfo")

def is_rules_python_generated_source(basename, target_name):
    """Returns True if the file is a file generated by rules_python."""

    # Note: This pattern may change with the version of rules_python used.
    return basename == target_name + "_entry_point.py"

def _filter_out_rules_python_generated_sources(srcs, ctx):
    """Filters out entry-point files generated by rules_python.

    Args:
        srcs: Sources to filter
        ctx: Context
    Returns:
        The filtered list of sources.
    """
    filtered = []
    for src in srcs:
        if not is_rules_python_generated_source(src.basename, ctx.label.name):
            filtered.append(src)
    return filtered

def map_import_path_for_python_path(ctx, path):
    """Maps paths for use with PYTHONPATH.

    Args:
        path: Import path to map.
        ctx: Context
    Returns:
        The mapped path
    """
    if "_virtual_imports" in path:
        if path.startswith("_main/"):
            # Proto in external repo
            #   - _main/external/path/_virtual_imports/proto -> $(BINDIR)/external/path/_virtual_imports/proto
            # Generated proto from this repo
            #   - _main/path/_virtual_imports/proto -> $(BINDIR)/path/_virtual_imports/proto
            # Importable runfile from this repo
            #   - _main/path/_foo_runfile_virtual_imports -> $(BINDIR)/path/_foo_runfile_virtual_imports
            return ctx.var["BINDIR"] + "/" + path.removeprefix("_main/")
        elif "+" in path:
            # Importable runfile in external repo
            #   - project+/path/_virtual_imports/proto -> $(BINDIR)/external/project+/path/_virtual_imports/proto
            return ctx.var["BINDIR"] + "/external/" + path  # buildifier: disable=external-path
        else:
            fail("Unhandled case for mapping a path for use in PYTHONPATH: ", path)
    elif "+" in path:
        # py_library in external repo
        #   - project+/path -> external/project+/path
        return "external/" + path
    elif path.startswith("_main/"):
        # py_library in this repo
        #   - _main/path -> path
        return path.removeprefix("_main/")
    else:
        fail("Unhandled case for mapping a path for use in PYTHONPATH: ", path)

PylintAspectForTestInfo = provider(
    doc = "Useful only for testing pylint_aspect",
    fields = {
        "python_path": "list of the strings used to build PYTHONPATH",
        "sources": "list of the python file paths that were linted",
    },
)

def _pylint_aspect_impl(target, ctx):
    # We check for providers here because we can't rely on `required_providers`;
    # see comment at the bottom of this file.
    if PyInfo not in target:
        return []

    if not hasattr(ctx.rule.files, "srcs"):
        return []

    # Skip linting for files generated by rules_python.
    direct_srcs = _filter_out_rules_python_generated_sources(ctx.rule.files.srcs, ctx)
    if not direct_srcs:
        return []

    # pylint is designed to be run from a Python environment in which the linted
    # modules are already installed, but in Bazel such an environment does not
    # exist. Build up the PYTHONPATH to so that all imports are successfully
    # found.
    #
    # TODO: b/248343713 - Refactor this to use rules_python's get_imports helper
    # (perhaps as part of upstreaming this to rules_python).
    python_path = [
        # Other direct srcs of the current build target which are plain .py
        # files will be found at paths relative to the execroot.
        ".",
        # Other direct srcs of the current build target which are generated
        # files will be found in the bindir.
        ctx.var["BINDIR"],
    ]
    for path in target[PyInfo].imports.to_list():
        python_path.append(map_import_path_for_python_path(ctx, path))

    # Ensure all transitive_sources workspace roots are in the PYTHONPATH so
    # they can be imported.
    workspace_roots = {}
    for src in target[PyInfo].transitive_sources.to_list():
        if src.owner.workspace_root:
            workspace_roots[src.owner.workspace_root] = True
    for root in workspace_roots.keys():
        python_path.append(root)
        python_path.append(ctx.var["BINDIR"] + "/" + root)

    outputs = []
    for src in direct_srcs:
        output_file = ctx.actions.declare_file(ctx.label.name + "." + src.path + ".pylint.txt")
        outputs.append(output_file)

        args = ctx.actions.args()
        args.add("--rcfile", ctx.file._pylintrc.path)

        # Prevent pylint from escaping the sandbox and caching the results of
        # past runs.  Weirdly, the pylint docs don't discuss what the persisted
        # data is actually used for; https://stackoverflow.com/q/25475327
        # suggests it's for reporting improvements in some global "score".
        args.add("--persistent", "False")

        # Write the output to file, and also print it (colorized) to the
        # console. (pylint only prints any output if at least one check fails.)
        args.add("--output-format", "text:" + output_file.path + ",colorized")

        # TODO: b/248343713 - See
        # https://pigweed.dev/get_started/analysis.html#known-limitations
        args.add("--disable=wrong-import-order")
        args.add(src)

        ctx.actions.run(
            executable = ctx.executable._pylint,
            inputs = depset(
                direct = direct_srcs + ctx.files._pylintrc,
                transitive = [target[PyInfo].transitive_sources],
            ),
            outputs = [output_file],
            arguments = [args],
            mnemonic = "Pylint",
            progress_message = "Pylinting " + str(ctx.label) + " (" + src.basename + ")",
            env = {"PYTHONPATH": ctx.configuration.host_path_separator.join(python_path)},
        )

    return [
        OutputGroupInfo(report = depset(direct = outputs)),
        PylintAspectForTestInfo(
            sources = [src.short_path for src in direct_srcs],
            python_path = python_path,
        ),
    ]

pylint_aspect = aspect(
    implementation = _pylint_aspect_impl,
    # We don't actually need to propagate up the graph.
    attr_aspects = [],
    attrs = {
        "_pylint": attr.label(
            default = Label("@pigweed//pw_build:pylint"),
            executable = True,
            cfg = "exec",
        ),
        "_pylintrc": attr.label(
            default = Label("@pigweed//pw_build:pylintrc"),
            allow_single_file = True,
        ),
    },
    required_providers = [[PyInfo]],
)
